---
alwaysApply: true
---
Avoid using the global app object, app (or window.app). Instead, use the reference provided by your plugin instance, this.app.

The global app object is intended for debugging purposes and might be removed in the future.

Please avoid unnecessary logging. In it's default configuration, the developer console should only show error messages, debug messages should not be shown.

Consider organizing your code base using folders 
If your plugin uses more than one .ts file, consider organizing them into folders to make it easier to review and maintain.

The Node.js API, and the Electron API aren't available on mobile devices. Any calls to these libraries made by your plugin or it's dependencies can cause your plugin to crash.

Lookbehind in regular expressions is only supported on iOS 16.4 and above, and some iPhone and iPad users may still use earlier versions. To implement a fallback for iOS users, either refer to Platform-specific features, or use a JavaScript library to detect specific browser versions.

Section headings don't have "settings" in the heading text.

Use Sentence case in UI.

For more information on writing and formatting text for Obsidian, refer to our Style guide.

Only use headings under settings if you have more than one section. 
Avoid adding a top-level heading in the settings tab, such as "General", "Settings", or the name of your plugin.

If you have more than one section under settings, and one contains general settings, keep them at the top without adding a heading.

For example, look at the settings under Settings → Appearance.

Avoid "settings" in settings headings 
In the settings tab, you can add headings to organize settings. Avoid including the word "settings" to these headings. Since everything in under the settings tab is settings, repeating it for every heading becomes redundant.

Prefer "Advanced" over "Advanced settings".
Prefer "Templates" over "Settings for templates".
Use sentence case in UI 
Any text in UI elements should be using Sentence case instead of Title Case, where only the first word in a sentence, and proper nouns, should be capitalized.

Prefer "Template folder location" over "Template Folder Location".
Prefer "Create new note" over "Create New Note".
Use setHeading instead of a <h1>, <h2> 
Using the heading elements from HTML will result in inconsistent styling between different plugins.
Instead you should prefer the following:

new Setting(containerEl).setName('your heading title').setHeading();
Security 
Avoid innerHTML, outerHTML and insertAdjacentHTML 
Building DOM elements from user-defined input, using innerHTML, outerHTML and insertAdjacentHTML can pose a security risk.

The following example builds a DOM element using a string that contains user input, ${name}. name can contain other DOM elements, such as <script>alert()</script>, and can allow a potential attacker to execute arbitrary code on the user's computer.

function showName(name: string) {
  let containerElement = document.querySelector('.my-container');
  // DON'T DO THIS
  containerElement.innerHTML = `<div class="my-class"><b>Your name is: </b>${name}</div>`;
}
Instead, use the DOM API or the Obsidian helper functions, such as createEl(), createDiv() and createSpan() to build the DOM element programmatically. For more information, refer to HTML elements.

To cleanup a HTML elements contents use el.empty();

Resource management 
Clean up resources when plugin unloads 
Any resources created by the plugin, such as event listeners, must be destroyed or released when the plugin unloads.

When possible, use methods like registerEvent() or addCommand() to automatically clean up resources when the plugin unloads.

export default class MyPlugin extends Plugin {
  onload() {
    this.registerEvent(this.app.vault.on('create', this.onCreate));
  }

  onCreate: (file: TAbstractFile) => {
    // ...
  }
}
Note
You don't need to clean up resources that are guaranteed to be removed when your plugin unloads. For example, if you register a mouseenter listener on a DOM element, the event listener will be garbage-collected when the element goes out of scope.

Don't detach leaves in onunload 
When the user updates your plugin, any open leaves will be reinitialized at their original position, regardless of where the user had moved them.

Commands 
Avoid setting a default hotkey for commands 
Setting a default hotkey may lead to conflicts between plugins and may override hotkeys that the user has already configured.

It's also difficult to choose a default hotkey that is available on all operating systems.

Use the appropriate callback type for commands 
When you add a command in your plugin, use the appropriate callback type.

Use callback if the command runs unconditionally.
Use checkCallback if the command only runs under certain conditions.
If the command requires an open and active Markdown editor, use editorCallback, or the corresponding editorCheckCallback.

Workspace 
Avoid accessing workspace.activeLeaf directly 
If you want to access the active view, use getActiveViewOfType() instead:

const view = this.app.workspace.getActiveViewOfType(MarkdownView);

// getActiveViewOfType will return null if the active view is null, or if it's not a MarkdownView.
if (view) {
  // ...
}
If you want to access the editor in the active note, use activeEditor instead:

const editor = this.app.workspace.activeEditor?.editor;

if (editor) {
    // ...
}
Avoid managing references to custom views 
Managing references to custom view can cause memory leaks or unintended consequences.

Don't do this:

this.registerView(MY_VIEW_TYPE, () => this.view = new MyCustomView());
Do this instead:

this.registerView(MY_VIEW_TYPE, () => new MyCustomView());
To access the view from your plugin, use Workspace.getActiveLeavesOfType():

for (let leaf of app.workspace.getActiveLeavesOfType(MY_VIEW_TYPE)) {
  let view = leaf.view;
  if (view instanceof MyCustomView) {
    // ...
  }
}
Vault 
Prefer the Editor API instead of Vault.modify to the active file 
If you want to edit an active note, use the Editor interface instead of Vault.modify().

Editor maintains information about the active note, such as cursor position, selection, and folded content. When you use Vault.modify() to edit the note, all that information is lost, which leads to a poor experience for the user.

Editor is also more efficient when making small changes to parts of the note.

Prefer Vault.process instead of Vault.modify to modify a file in the background 
If you want to edit a note that is not currently opened, use the Vault.process function instead of Vault.modify.

The process function modifies the file atomically, which means that your plugin won't run into conflicts with other plugins modifying the same file.

Prefer FileManager.processFrontMatter to modify frontmatter of a note 
Instead of extracting the frontmatter of a note, parsing and modifying the YAML manually you should use the FileManager.processFrontMatter function.

processFrontMatter runs atomically, so modifying the file will not conflict with other plugins editing the same file.
It will also ensure a consistent layout of the YAML produced.

Prefer the Vault API over the Adapter API 
Obsidian exposes two APIs for file operations: the Vault API (app.vault) and the Adapter API (app.vault.adapter).

While the file operations in the Adapter API are often more familiar to many developers, the Vault API has two main advantages over the adapter.

Performance: The Vault API has a caching layer that can speed up file reads when the file is already known to Obsidian.
Safety: The Vault API performs file operations serially to avoid any race conditions, for example when reading a file that is being written to at the same time.
Avoid iterating all files to find a file by its path 
This is inefficient, especially for large vaults. Use Vault.getFileByPath, Vault.getFolderByPath or Vault.getAbstractFileByPath instead.

Don't do this:

this.app.vault.getFiles().find(file => file.path === filePath);
Do this instead:

const filePath = 'folder/file.md';
// if you want to get a file
const file = this.app.vault.getFileByPath(filePath);
const folderPath = 'folder';
// or if you want to get a folder
const folder = this.app.vault.getFolderByPath(folderPath);
If you aren't sure if the path provided is for a folder or a file, use:

const abstractFile = this.app.vault.getAbstractFileByPath(filePath);

if (file instanceof TFile) {
	// it's a file
}
if (file instanceof TFolder) {
	// it's a folder
}
Use normalizePath() to clean up user-defined paths 
Use normalizePath() whenever you accept user-defined paths to files or folders in the vault, or when you construct your own paths in the plugin code.

normalizePath() takes a path and scrubs it to be safe for the file system and for cross-platform use. This function:

Cleans up the use of forward and backward slashes, such as replacing 1 or more of \ or / with a single /.
Removes leading and trailing forward and backward slashes.
Replaces any non-breaking spaces, \u00A0, with a regular space.
Runs the path through String.prototype.normalize.
import { normalizePath } from 'obsidian';
const pathToPlugin = normalizePath('//my-folder\file');
// pathToPlugin contains "my-folder/file" not "//my-folder\"
Editor 
Change or reconfigure editor extensions 
If you want to change or reconfigure an editor extension after you've registered using registerEditorExtension(), use updateOptions() to update all editors.

class MyPlugin extends Plugin {
  private editorExtension: Extension[] = [];

  onload() {
    //...

    this.registerEditorExtension(this.editorExtension);
  }

  updateEditorExtension() {
    // Empty the array while keeping the same reference
    // (Don't create a new array here)
    this.editorExtension.length = 0;

    // Create new editor extension
    let myNewExtension = this.createEditorExtension();
    // Add it to the array
    this.editorExtension.push(myNewExtension);

    // Flush the changes to all editors
    this.app.workspace.updateOptions();
  }
}

Styling 
No hardcoded styling 
Don't do this:

const el = containerEl.createDiv();
el.style.color = 'white';
el.style.backgroundColor = 'red';
To make it easy for users to modify the styling of your plugin you should use CSS classes, as hardcoding the styling in the plugin code makes it impossible to modify with themes and snippets.

Do this instead:

const el = containerEl.createDiv({cls: 'warning-container'});
In the plugins CSS add the following:

.warning-container {
	color: var(--text-normal);
	background-color: var(--background-modifier-error);
}
To make the styling of your plugin consistent with Obsidian and other plugins you should use the CSS variables provided by Obsidian.
If there is no variable available that fits in your case, you can create your own.

TypeScript 
Prefer const and let over var 
For more information, refer to 4 Reasons Why var is Considered Obsolete in Modern JavaScript.

Prefer async/await over Promise 
Recent versions of JavaScript and TypeScript support the async and await keywords to run code asynchronously, which allow for more readable code than using Promises.

Don't do this:

function test(): Promise<string | null> {
  return requestUrl('https://example.com')
    .then(res => res.text
    .catch(e => {
      console.log(e);
      return null;
    });
}
Do this instead:

async function AsyncTest(): Promise<string | null> {
  try {
    let res = await requestUrl('https://example.com');
    let text = await r.text;
    return text;
  }
  catch (e) {
    console.log(e);
    return null;
  }
}


Language style 
For our English documentation, it is recommended to use Global English to better serve our worldwide audience.

Terms 
Prefer "keyboard shortcut" over "hotkey". Use Hotkey when referring to the specific feature.
Prefer "the Obsidian app" on mobile, and "the Obsidian application" on desktop.
Prefer "sync" or "syncing" over "synchronise" or "synchronising".
Prefer "search term" over "search query".
Prefer "heading" over "header" when referring to a text that introduces a section.
Prefer "maximum" over "max" and "minimum" over "min".
Product names 
Obsidian product names start with "Obsidian", for example "Obsidian Publish" and "Obsidian Sync".

If a paragraph becomes overly repetitive, you can use the short form in subsequent references.

For example:

To allow device-specific configuration, Obsidian Sync doesn't sync its own settings. You need to configure Sync for each of your devices.

UI and interactions 
Use bold to indicate button text
Prefer "select" over "tap" or "click".
Prefer "sidebar" over "side bar".
Prefer "perform" over "invoke" and "execute" when referring to commands or actions.
When referring to multiple UI interactions in a sequence, use the → (U+2192) symbol. For example, "Settings → Community plugins".

Notes, files, and folders 
Use "note" when referring to a Markdown file in the vault.
Use "file" when referring to other file extensions than Markdown.
Prefer "note name" over "note title".
Prefer "active note" over "current note".
Prefer "folder" over "directory".
Prefer "file type" over "file format", unless specifically referring to the data format of the file content.
When moving between notes, use "open" if the destination is hidden, and "switch" if both source and destination notes are open in separate splits.

Reference documentation for settings 
When possible, any settings should be documented within Obsidian using a descriptive text. Avoid documenting a specific setting in Obsidian Help unless:

It requires more in-depth knowledge on how and when to use it.
It's commonly misused or asked about.
It drastically changes the user experience.
Consider using a tip callout if you want to draw attention to a specific setting.

Directional terms 
Hyphenate directional terms when using them as adjectives. Avoid hyphenation when direction is used as a noun.

Recommended:

Select Settings in the bottom-left corner.
Select Settings in the bottom left.
Not recommended:

Select Settings in the bottom left corner.
Select Settings in the bottom-left.
Prefer "upper-left" and "upper-right" over "top-left" and "top-right".

Don't indicate a direction when referring to settings. The location of the settings control depends on the device.

Recommended:

Next to Pick remote vault, select Choose.
Not recommended:

To the right of Pick remote vault, select Choose.
Instructions 
Use imperatives for the names of guides, section headings, and step-by-step instructions. The imperative mood is concise and action-oriented, which is more straightforward for users following instructions.

Prefer "Set up" over "Setting up"
Prefer "Move a file" over "Moving a file"
Prefer "Import your notes" over "Importing your notes"
Sentence case 
Prefer sentence case over title case for headings, buttons, and titles. When referencing UI elements always match the case of the text in the UI.

Recommended:

How Obsidian stores data
Not recommended:

How Obsidian Stores Data
Examples 
Prefer realistic examples over nonsense terms.

Recommended:

task:(call OR schedule)
Not recommended:

task:(foo OR bar)
Key names 
When referring to a character on the keyboard by name, add the character between parentheses right after the name:

Recommended:

Add a hyphen (-) in front of the word.
Not recommended:

Add a hyphen in front of the word.
Add a - in front of the word.
Markdown 
Use newlines between Markdown blocks:

Recommended:

# Heading 1

This is a section.

1. First item
2. Second item
3. Third item
Not recommended:

# Heading 1
This is a section.
1. First item
2. Second item
3. Third item
Images 
Use "width x height pixels" for describing image or screen dimensions.

Example:

Recommended image dimensions: 1920 x 1080 pixels.

Icons and images 
Include icons and images when they make it easier to explain things that are hard to describe with words, or when you need to show important parts of the Obsidian application. You can save images in the Attachments folder.

The image should make the text it accompanies easier to understand.

Example: Once enabled, the Word count plugin will create a new entry on your bottom statusbar.

Style-guide-zoomed-example.png#interface

Images should be in either .png or .svg format.
If an image looks too big in the note, make it smaller outside of Obsidian, or adjust its dimensions as explained in embedding an image in a note.
In rare cases, you may want to place especially large or complex images in a folded callout.
For pop-up windows or modals, the image should show the entire Obsidian application window.
Style-guide-modal-example.png > interface
Icons 
Lucide and custom Obsidian icons can be used alongside detailed elements to provide a visual representation of a feature.

Example: In the ribbon on the left, select Create new canvas ( lucide-layout-dashboard.svg > icon ) to create a canvas in the same folder as the active file.

Guidelines for icons

Store icons in the Attachments/icons folder.
Add the prefix lucide- before the Lucide icon name.
Add the prefix obsidian-icon- before the Obsidian icon name.
Example: The icon for creating a new canvas should be named lucide-layout-dashboard.

Use the SVG version of the icons available.
Icons should be 18 pixels in width, 18 pixels in height, and have a stroke width of 1.5. You can adjust these settings in the SVG data.
Adjusting size and stroke in an SVG
Utilize the icon anchor in embedded images, to tweak the spacing around the icon so that it aligns neatly with the text in the vicinity.
Icons should be surrounded by parenthesis. ( lucide-cog.svg > icon )
Example: ( ![[lucide-cog.svg#icon]] )

Image anchor tags 
Image anchors tags are available to add decorative changes to the embedded images.

Live preview warning
The icon anchor tags will not display correctly in Live preview. Use Reading view to confirm the anchor tag has been applied.

Icon

![[lucide-menu.svg#icon]]

The icon anchor tag ensures correct vertical alignment for icons used to indicate interface elements.

The first menu icon uses the anchor tag ( lucide-menu.svg > icon ), while the second menu icon ( lucide-menu.svg ) does not.

Interface

![[Vault picker.png#interface]]

The interface anchor tag adds a decorative box shadow around the image. In the first image, the interface anchor tag is applied.
Vault picker.png > interface

In contrast, the second image does not have the interface anchor applied.

Vault picker.png

Outline

![[Backlinks.png#outline]]

The outline anchor tag adds a subtle border around the image. In the first image, the outline anchor tag is applied.

Observe the lower left of the image to see the difference.
Backlinks.png > outline

The second image lacks the outline anchor tag.

Backlinks.png

Optimization 
Images slow the loading time of the page, and take valuable Publish storage space. Optimizing images allows a reduction in file size, but maintains the visual integrity of the image.

Both images and icons should be optimized.

Tools for optimizing images
Here are a some recommended programs for reducing the size of your images.

Windows: FileOptimizer
macOS: ImageOptim
Linux/Unix Trimage
We recommend an optimization rate of 65-75%.

Layout 
Broken links 
Before submitting your Pull Request, please check for any broken links in the documentation of the translation you are working on and correct them. Broken links can occur naturally over time, so verifying their accuracy helps maintain the quality of the documentation.

You can check for broken links using Community plugins or tools available in your IDE.

Descriptions 
This documentation is edited on GitHub and hosted online via Obsidian Publish, which includes descriptions for social cards and other SEO elements.

If the page you are working on does not have a description property, please add one. The description should be 150 characters or fewer and provide an objective summary of the page’s content.

Good: Learn to create templates that capture and organize web page metadata automatically with Web Clipper.
Could be tweaked: Learn how to create templates that automatically capture and organize metadata from web pages with Web Clipper.

Directions 
When writing or rewriting Instructions on how to perform an action within the app, be sure to include steps for both the mobile and desktop versions.

If you do not have access to a mobile or desktop device, please mention this when submitting your Pull Request.

Translations 
Translate the entirety of the content when completing a translation. This includes and is not limited to:

Note names
Folder names
Aliases
Attachment names
Alt link text
